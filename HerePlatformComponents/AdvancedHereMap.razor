@using HerePlatformComponents.Maps
@using HerePlatformComponents.Maps.Clustering
@using HerePlatformComponents.Maps.Data
@using HerePlatformComponents.Maps.Events
@using HerePlatformComponents.Maps.Extension
@using Microsoft.JSInterop
@inherits ComponentBase
@inject IJSRuntime Js
@implements IAsyncDisposable

<HereMap @ref="@MapRef" Id="@Id" Height="@Height" Options="@Options" OnAfterInit="@AfterInit" CssClass="@CssClass" />

@if (MapRef?.InteropObject is not null)
{
    <CascadingValue Name="HereMap" Value="@this" IsFixed="true">
        @ChildContent
    </CascadingValue>
}

@code {
    public HereMap? MapRef;

    public Map? InteropObject => MapRef?.InteropObject;

    internal Guid? MapId => MapRef?.InteropObject.Guid;

    public int MarkerCount => _mapComponents.Count;
    public IEnumerable<MarkerComponent> Markers => _mapComponents.Select(x => x.Value);
    private readonly Dictionary<Guid, MarkerComponent> _mapComponents = [];

    public int PolygonCount => _mapPolygonComponents.Count;
    public IEnumerable<PolygonComponent> Polygons => _mapPolygonComponents.Select(x => x.Value);
    private readonly Dictionary<Guid, PolygonComponent> _mapPolygonComponents = [];

    public int PolylineCount => _mapPolylineComponents.Count;
    public IEnumerable<PolylineComponent> Polylines => _mapPolylineComponents.Select(x => x.Value);
    private readonly Dictionary<Guid, PolylineComponent> _mapPolylineComponents = [];

    public int CircleCount => _mapCircleComponents.Count;
    public IEnumerable<CircleComponent> Circles => _mapCircleComponents.Select(x => x.Value);
    private readonly Dictionary<Guid, CircleComponent> _mapCircleComponents = [];

    public int RectCount => _mapRectComponents.Count;
    public IEnumerable<RectComponent> Rects => _mapRectComponents.Select(x => x.Value);
    private readonly Dictionary<Guid, RectComponent> _mapRectComponents = [];

    public int GroupCount => _mapGroupComponents.Count;
    public IEnumerable<GroupComponent> Groups => _mapGroupComponents.Select(x => x.Value);
    private readonly Dictionary<Guid, GroupComponent> _mapGroupComponents = [];

    public int DomMarkerCount => _mapDomMarkerComponents.Count;
    public IEnumerable<DomMarkerComponent> DomMarkers => _mapDomMarkerComponents.Select(x => x.Value);
    private readonly Dictionary<Guid, DomMarkerComponent> _mapDomMarkerComponents = [];

    public int InfoBubbleCount => _mapInfoBubbleComponents.Count;
    public IEnumerable<InfoBubbleComponent> InfoBubbles => _mapInfoBubbleComponents.Select(x => x.Value);
    private readonly Dictionary<Guid, InfoBubbleComponent> _mapInfoBubbleComponents = [];

    private readonly Dictionary<Guid, MarkerClusterComponent> _mapClusterComponents = [];
    private readonly Dictionary<Guid, GeoJsonReaderComponent> _mapGeoJsonComponents = [];
    private readonly Dictionary<Guid, KmlReaderComponent> _mapKmlComponents = [];

    internal DotNetObjectReference<AdvancedHereMap>? CallbackRef;

    [Parameter]
    public string? Id { get; set; }

    [Parameter]
    public MapOptions? Options { get; set; }

    [Parameter]
    public EventCallback OnAfterInit { get; set; }

    /// <summary>
    /// When true, programmatic SetCenter/SetZoom/SetTilt/SetHeading changes are animated.
    /// </summary>
    [Parameter]
    public bool Animate { get; set; }

    /// <summary>
    /// Bitmask of behavior features to disable on this map.
    /// </summary>
    [Parameter]
    public BehaviorFeature DisabledBehaviors { get; set; }

    /// <summary>
    /// Viewport padding. Applied when changed after map init.
    /// </summary>
    [Parameter]
    public Padding? ViewportPadding { get; set; }

    [Parameter]
    public EventCallback OnMarkersChanged { get; set; }

    [Parameter]
    public EventCallback OnPolygonsChanged { get; set; }

    [Parameter]
    public EventCallback OnPolylinesChanged { get; set; }

    [Parameter]
    public EventCallback OnCirclesChanged { get; set; }

    [Parameter]
    public EventCallback OnRectsChanged { get; set; }

    [Parameter]
    public string? CssClass { get; set; }

    [Parameter]
    public string? Height { get; set; }

    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    #region Two-Way Bindable View Parameters

    /// <summary>
    /// Map center position. Two-way bindable via <c>@bind-Center</c>.
    /// When set, overrides Options.Center. Updated when the user pans the map.
    /// </summary>
    [Parameter]
    public LatLngLiteral? Center { get; set; }

    /// <summary>
    /// Callback for two-way binding of <see cref="Center"/>.
    /// Fired when the user finishes panning (on mapviewchangeend).
    /// </summary>
    [Parameter]
    public EventCallback<LatLngLiteral> CenterChanged { get; set; }

    /// <summary>
    /// Map zoom level. Two-way bindable via <c>@bind-Zoom</c>.
    /// When set, overrides Options.Zoom. Updated when the user zooms the map.
    /// </summary>
    [Parameter]
    public double? Zoom { get; set; }

    /// <summary>
    /// Callback for two-way binding of <see cref="Zoom"/>.
    /// Fired when the user finishes zooming (on mapviewchangeend).
    /// </summary>
    [Parameter]
    public EventCallback<double> ZoomChanged { get; set; }

    /// <summary>
    /// Map tilt angle in degrees. Two-way bindable via <c>@bind-Tilt</c>.
    /// When set, overrides Options.Tilt. Updated on user tilt gesture.
    /// </summary>
    [Parameter]
    public double? Tilt { get; set; }

    /// <summary>
    /// Callback for two-way binding of <see cref="Tilt"/>.
    /// Fired when the user finishes tilting (on mapviewchangeend).
    /// </summary>
    [Parameter]
    public EventCallback<double> TiltChanged { get; set; }

    /// <summary>
    /// Map heading (rotation) in degrees. Two-way bindable via <c>@bind-Heading</c>.
    /// When set, overrides Options.Heading. Updated on user rotation gesture.
    /// </summary>
    [Parameter]
    public double? Heading { get; set; }

    /// <summary>
    /// Callback for two-way binding of <see cref="Heading"/>.
    /// Fired when the user finishes rotating (on mapviewchangeend).
    /// </summary>
    [Parameter]
    public EventCallback<double> HeadingChanged { get; set; }

    #endregion

    #region Map-level Pointer / Interaction EventCallbacks

    /// <summary>
    /// Fired when the map background is tapped/clicked (no object hit).
    /// </summary>
    [Parameter]
    public EventCallback<MapPointerEventArgs> OnClick { get; set; }

    /// <summary>
    /// Fired on double-tap/double-click on the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapPointerEventArgs> OnDoubleClick { get; set; }

    /// <summary>
    /// Fired on long press on the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapPointerEventArgs> OnLongPress { get; set; }

    /// <summary>
    /// Fired on right-click on the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapPointerEventArgs> OnContextMenu { get; set; }

    /// <summary>
    /// Fired when context menu interaction ends.
    /// </summary>
    [Parameter]
    public EventCallback OnContextMenuClose { get; set; }

    /// <summary>
    /// Fired when a pointer touches the map surface.
    /// </summary>
    [Parameter]
    public EventCallback<MapPointerEventArgs> OnPointerDown { get; set; }

    /// <summary>
    /// Fired when a pointer leaves the map surface.
    /// </summary>
    [Parameter]
    public EventCallback<MapPointerEventArgs> OnPointerUp { get; set; }

    /// <summary>
    /// Fired when a pointer moves over the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapPointerEventArgs> OnPointerMove { get; set; }

    /// <summary>
    /// Fired when a pointer enters the map area.
    /// </summary>
    [Parameter]
    public EventCallback<MapPointerEventArgs> OnPointerEnter { get; set; }

    /// <summary>
    /// Fired when a pointer leaves the map area.
    /// </summary>
    [Parameter]
    public EventCallback<MapPointerEventArgs> OnPointerLeave { get; set; }

    /// <summary>
    /// Fired when a pointer action is cancelled.
    /// </summary>
    [Parameter]
    public EventCallback OnPointerCancel { get; set; }

    /// <summary>
    /// Fired when a drag operation starts on the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapDragEventArgs> OnDragStart { get; set; }

    /// <summary>
    /// Fired continuously during a map drag.
    /// </summary>
    [Parameter]
    public EventCallback<MapDragEventArgs> OnDrag { get; set; }

    /// <summary>
    /// Fired when a drag operation ends on the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapDragEventArgs> OnDragEnd { get; set; }

    /// <summary>
    /// Fired on mouse wheel scroll over the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapWheelEventArgs> OnWheel { get; set; }

    #endregion

    #region Map-specific EventCallbacks

    /// <summary>
    /// Fired when the base layer changes.
    /// </summary>
    [Parameter]
    public EventCallback<BaseLayerChangeEventArgs> OnBaseLayerChange { get; set; }

    /// <summary>
    /// Fired when the render engine state changes.
    /// </summary>
    [Parameter]
    public EventCallback<EngineStateChangeEventArgs> OnEngineStateChange { get; set; }

    /// <summary>
    /// Fired continuously while the map view changes (zoom, pan, tilt).
    /// </summary>
    [Parameter]
    public EventCallback<MapViewChangeEventArgs> OnMapViewChange { get; set; }

    /// <summary>
    /// Fired when a map view change starts.
    /// </summary>
    [Parameter]
    public EventCallback<MapViewChangeEventArgs> OnMapViewChangeStart { get; set; }

    /// <summary>
    /// Fired when a map view change ends.
    /// </summary>
    [Parameter]
    public EventCallback<MapViewChangeEventArgs> OnMapViewChangeEnd { get; set; }

    #endregion

    protected override void OnInitialized()
    {
        CallbackRef = DotNetObjectReference.Create(this);
        base.OnInitialized();
    }

    public override async Task SetParametersAsync(ParameterView parameters)
    {
        // Before map is initialized: merge individual params into Options for initial render
        if (MapRef?.InteropObject is null)
        {
            await base.SetParametersAsync(parameters);

            if (Options != null)
            {
                if (Center.HasValue) Options.Center = Center.Value;
                if (Zoom.HasValue) Options.Zoom = Zoom.Value;
                if (Tilt.HasValue) Options.Tilt = Tilt;
                if (Heading.HasValue) Options.Heading = Heading;
            }

            return;
        }

        // After init: detect which view parameters changed before base updates them
        var centerChanged = parameters.DidParameterChange(Center);
        var zoomChanged = parameters.DidParameterChange(Zoom);
        var tiltChanged = parameters.DidParameterChange(Tilt);
        var headingChanged = parameters.DidParameterChange(Heading);

        await base.SetParametersAsync(parameters);

        // Push programmatic changes to the JS map
        if (centerChanged && Center.HasValue)
            await MapRef.InteropObject.SetCenter(Center.Value, Animate);
        if (zoomChanged && Zoom.HasValue)
            await MapRef.InteropObject.SetZoom(Zoom.Value, Animate);
        if (tiltChanged && Tilt.HasValue)
            await MapRef.InteropObject.SetTilt(Tilt.Value);
        if (headingChanged && Heading.HasValue)
            await MapRef.InteropObject.SetHeading(Heading.Value);
    }

    private async Task AfterInit()
    {
        // Wire up map-level events now that the map is ready
        if (MapId.HasValue)
        {
            await Js.InvokeVoidAsync("blazorHerePlatform.objectManager.setupMapEvents", MapId.Value, CallbackRef);
        }

        // Apply initial DisabledBehaviors
        if (DisabledBehaviors != BehaviorFeature.None && MapRef?.InteropObject != null)
        {
            await MapRef.InteropObject.DisableBehavior(DisabledBehaviors);
        }

        // Apply initial ViewportPadding
        if (ViewportPadding != null && MapRef?.InteropObject != null)
        {
            await MapRef.InteropObject.SetViewportPadding(
                ViewportPadding.Top, ViewportPadding.Right,
                ViewportPadding.Bottom, ViewportPadding.Left);
        }

        await OnAfterInit.InvokeAsync();
    }

    #region JSInvokable — Marker events

    [JSInvokable]
    public async Task OnMarkerClicked(Guid markerId)
    {
        // Legacy compat: still called by old JS for simple tap without event data.
        // New path uses OnObjectPointerEvent instead.
        if (_mapComponents.TryGetValue(markerId, out var markerComponent))
        {
            await markerComponent.HandlePointerEvent("tap", new MapPointerEventArgs { Type = "tap" });
        }
    }

    [JSInvokable]
    public async Task OnMarkerDrag(Guid markerId, LatLngLiteral position)
    {
        // Legacy compat: still called by old JS for dragend.
        if (_mapComponents.TryGetValue(markerId, out var markerComponent))
        {
            await markerComponent.HandleDragEvent("dragend", new MapDragEventArgs
            {
                Position = position,
                Type = "dragend"
            });
        }
    }

    #endregion

    #region JSInvokable — Polygon events

    [JSInvokable]
    public async Task OnPolygonClicked(Guid polygonId)
    {
        // Legacy compat
        if (_mapPolygonComponents.TryGetValue(polygonId, out var polygonComponent))
        {
            await polygonComponent.HandlePointerEvent("tap", new MapPointerEventArgs { Type = "tap" });
        }
    }

    #endregion

    #region JSInvokable — Unified object events (new)

    /// <summary>
    /// Called from JS for pointer events on markers and polygons.
    /// </summary>
    [JSInvokable]
    public async Task OnObjectPointerEvent(string objectType, Guid objectId, string eventName, MapPointerEventArgs args)
    {
        if (objectType == "marker" && _mapComponents.TryGetValue(objectId, out var marker))
        {
            await marker.HandlePointerEvent(eventName, args);
        }
        else if (objectType == "polygon" && _mapPolygonComponents.TryGetValue(objectId, out var polygon))
        {
            await polygon.HandlePointerEvent(eventName, args);
        }
        else if (objectType == "polyline" && _mapPolylineComponents.TryGetValue(objectId, out var polyline))
        {
            await polyline.HandlePointerEvent(eventName, args);
        }
        else if (objectType == "circle" && _mapCircleComponents.TryGetValue(objectId, out var circle))
        {
            await circle.HandlePointerEvent(eventName, args);
        }
        else if (objectType == "rect" && _mapRectComponents.TryGetValue(objectId, out var rect))
        {
            await rect.HandlePointerEvent(eventName, args);
        }
        else if (objectType == "dommarker" && _mapDomMarkerComponents.TryGetValue(objectId, out var domMarker))
        {
            await domMarker.HandlePointerEvent(eventName, args);
        }
    }

    /// <summary>
    /// Called from JS for parameterless events (contextmenuclose, pointercancel) on objects.
    /// </summary>
    [JSInvokable]
    public async Task OnObjectSimpleEvent(string objectType, Guid objectId, string eventName)
    {
        if (objectType == "marker" && _mapComponents.TryGetValue(objectId, out var marker))
        {
            if (eventName == "contextmenuclose") await marker.HandleContextMenuClose();
            else if (eventName == "pointercancel") await marker.HandlePointerCancel();
        }
        else if (objectType == "polygon" && _mapPolygonComponents.TryGetValue(objectId, out var polygon))
        {
            if (eventName == "contextmenuclose") await polygon.HandleContextMenuClose();
            else if (eventName == "pointercancel") await polygon.HandlePointerCancel();
        }
        else if (objectType == "polyline" && _mapPolylineComponents.TryGetValue(objectId, out var polyline))
        {
            if (eventName == "contextmenuclose") await polyline.HandleContextMenuClose();
            else if (eventName == "pointercancel") await polyline.HandlePointerCancel();
        }
        else if (objectType == "circle" && _mapCircleComponents.TryGetValue(objectId, out var circle))
        {
            if (eventName == "contextmenuclose") await circle.HandleContextMenuClose();
            else if (eventName == "pointercancel") await circle.HandlePointerCancel();
        }
        else if (objectType == "rect" && _mapRectComponents.TryGetValue(objectId, out var rect))
        {
            if (eventName == "contextmenuclose") await rect.HandleContextMenuClose();
            else if (eventName == "pointercancel") await rect.HandlePointerCancel();
        }
        else if (objectType == "dommarker" && _mapDomMarkerComponents.TryGetValue(objectId, out var domMarker))
        {
            if (eventName == "contextmenuclose") await domMarker.HandleContextMenuClose();
            else if (eventName == "pointercancel") await domMarker.HandlePointerCancel();
        }
    }

    /// <summary>
    /// Called from JS for drag events on markers and polygons.
    /// </summary>
    [JSInvokable]
    public async Task OnObjectDragEvent(string objectType, Guid objectId, string eventName, MapDragEventArgs args)
    {
        if (objectType == "marker" && _mapComponents.TryGetValue(objectId, out var marker))
        {
            await marker.HandleDragEvent(eventName, args);
        }
        else if (objectType == "polygon" && _mapPolygonComponents.TryGetValue(objectId, out var polygon))
        {
            await polygon.HandleDragEvent(eventName, args);
        }
        else if (objectType == "polyline" && _mapPolylineComponents.TryGetValue(objectId, out var polyline))
        {
            await polyline.HandleDragEvent(eventName, args);
        }
        else if (objectType == "circle" && _mapCircleComponents.TryGetValue(objectId, out var circle))
        {
            await circle.HandleDragEvent(eventName, args);
        }
        else if (objectType == "rect" && _mapRectComponents.TryGetValue(objectId, out var rect))
        {
            await rect.HandleDragEvent(eventName, args);
        }
        else if (objectType == "dommarker" && _mapDomMarkerComponents.TryGetValue(objectId, out var domMarker))
        {
            await domMarker.HandleDragEvent(eventName, args);
        }
    }

    #endregion

    #region JSInvokable — InfoBubble events

    [JSInvokable]
    public async Task OnInfoBubbleClosed(Guid bubbleId)
    {
        if (_mapInfoBubbleComponents.TryGetValue(bubbleId, out var bubble))
        {
            await bubble.HandleClosed();
        }
    }

    #endregion

    #region JSInvokable — Cluster events

    [JSInvokable]
    public async Task OnClusterTapped(Guid clusterId, ClusterTapEventArgs args)
    {
        if (_mapClusterComponents.TryGetValue(clusterId, out var cluster))
        {
            await cluster.HandleClusterTap(args);
        }
    }

    [JSInvokable]
    public async Task OnNoiseTapped(Guid clusterId, ClusterTapEventArgs args)
    {
        if (_mapClusterComponents.TryGetValue(clusterId, out var cluster))
        {
            await cluster.HandleNoiseTap(args);
        }
    }

    #endregion

    #region JSInvokable — Data events

    [JSInvokable]
    public async Task OnGeoJsonLoaded(Guid componentId, GeoJsonLoadedEventArgs args)
    {
        if (_mapGeoJsonComponents.TryGetValue(componentId, out var reader))
        {
            await reader.HandleLoaded(args);
        }
    }

    [JSInvokable]
    public async Task OnKmlLoaded(Guid componentId, GeoJsonLoadedEventArgs args)
    {
        if (_mapKmlComponents.TryGetValue(componentId, out var reader))
        {
            await reader.HandleLoaded(args);
        }
    }

    #endregion

    #region JSInvokable — Map-level events (new)

    [JSInvokable]
    public async Task OnMapPointerEvent(string eventName, MapPointerEventArgs args)
    {
        var callback = eventName switch
        {
            "tap" => OnClick,
            "dbltap" => OnDoubleClick,
            "longpress" => OnLongPress,
            "contextmenu" => OnContextMenu,
            "pointerdown" => OnPointerDown,
            "pointerup" => OnPointerUp,
            "pointermove" => OnPointerMove,
            "pointerenter" => OnPointerEnter,
            "pointerleave" => OnPointerLeave,
            _ => default
        };

        if (callback.HasDelegate)
            await callback.InvokeAsync(args);
    }

    [JSInvokable]
    public async Task OnMapSimpleEvent(string eventName)
    {
        if (eventName == "contextmenuclose" && OnContextMenuClose.HasDelegate)
            await OnContextMenuClose.InvokeAsync();
        else if (eventName == "pointercancel" && OnPointerCancel.HasDelegate)
            await OnPointerCancel.InvokeAsync();
    }

    [JSInvokable]
    public async Task OnMapDragEvent(string eventName, MapDragEventArgs args)
    {
        var callback = eventName switch
        {
            "dragstart" => OnDragStart,
            "drag" => OnDrag,
            "dragend" => OnDragEnd,
            _ => default
        };

        if (callback.HasDelegate)
            await callback.InvokeAsync(args);
    }

    [JSInvokable]
    public async Task OnMapWheelEvent(MapWheelEventArgs args)
    {
        if (OnWheel.HasDelegate)
            await OnWheel.InvokeAsync(args);
    }

    [JSInvokable]
    public async Task OnMapViewChangeEvent(string eventName, MapViewChangeEventArgs args)
    {
        var callback = eventName switch
        {
            "mapviewchange" => OnMapViewChange,
            "mapviewchangestart" => OnMapViewChangeStart,
            "mapviewchangeend" => OnMapViewChangeEnd,
            _ => default
        };

        if (callback.HasDelegate)
            await callback.InvokeAsync(args);

        // Two-way binding: update bound parameters on view change end
        if (eventName == "mapviewchangeend")
        {
            if (CenterChanged.HasDelegate && args.Center.HasValue)
            {
                Center = args.Center.Value;
                await CenterChanged.InvokeAsync(args.Center.Value);
            }
            if (ZoomChanged.HasDelegate)
            {
                Zoom = args.Zoom;
                await ZoomChanged.InvokeAsync(args.Zoom);
            }
            if (TiltChanged.HasDelegate)
            {
                Tilt = args.Tilt;
                await TiltChanged.InvokeAsync(args.Tilt);
            }
            if (HeadingChanged.HasDelegate)
            {
                Heading = args.Heading;
                await HeadingChanged.InvokeAsync(args.Heading);
            }
        }
    }

    [JSInvokable]
    public async Task OnMapBaseLayerChangeEvent(BaseLayerChangeEventArgs args)
    {
        if (OnBaseLayerChange.HasDelegate)
            await OnBaseLayerChange.InvokeAsync(args);
    }

    [JSInvokable]
    public async Task OnMapEngineStateChangeEvent(EngineStateChangeEventArgs args)
    {
        if (OnEngineStateChange.HasDelegate)
            await OnEngineStateChange.InvokeAsync(args);
    }

    #endregion

    internal void AddMarker(MarkerComponent marker)
    {
        _mapComponents.TryAdd(marker.Guid, marker);
        OnMarkersChanged.InvokeAsync();
    }

    internal void RemoveMarker(MarkerComponent marker)
    {
        _mapComponents.Remove(marker.Guid);
        OnMarkersChanged.InvokeAsync();
    }

    internal void AddPolygon(PolygonComponent poly)
    {
        _mapPolygonComponents.TryAdd(poly.Guid, poly);
        OnPolygonsChanged.InvokeAsync();
    }

    internal void RemovePolygon(PolygonComponent poly)
    {
        _mapPolygonComponents.Remove(poly.Guid);
        OnPolygonsChanged.InvokeAsync();
    }

    internal void AddPolyline(PolylineComponent polyline)
    {
        _mapPolylineComponents.TryAdd(polyline.Guid, polyline);
        OnPolylinesChanged.InvokeAsync();
    }

    internal void RemovePolyline(PolylineComponent polyline)
    {
        _mapPolylineComponents.Remove(polyline.Guid);
        OnPolylinesChanged.InvokeAsync();
    }

    internal void AddCircle(CircleComponent circle)
    {
        _mapCircleComponents.TryAdd(circle.Guid, circle);
        OnCirclesChanged.InvokeAsync();
    }

    internal void RemoveCircle(CircleComponent circle)
    {
        _mapCircleComponents.Remove(circle.Guid);
        OnCirclesChanged.InvokeAsync();
    }

    internal void AddRect(RectComponent rect)
    {
        _mapRectComponents.TryAdd(rect.Guid, rect);
        OnRectsChanged.InvokeAsync();
    }

    internal void RemoveRect(RectComponent rect)
    {
        _mapRectComponents.Remove(rect.Guid);
        OnRectsChanged.InvokeAsync();
    }

    internal void AddGroup(GroupComponent group)
    {
        _mapGroupComponents.TryAdd(group.Guid, group);
    }

    internal void RemoveGroup(GroupComponent group)
    {
        _mapGroupComponents.Remove(group.Guid);
    }

    internal void AddDomMarker(DomMarkerComponent domMarker)
    {
        _mapDomMarkerComponents.TryAdd(domMarker.Guid, domMarker);
    }

    internal void RemoveDomMarker(DomMarkerComponent domMarker)
    {
        _mapDomMarkerComponents.Remove(domMarker.Guid);
    }

    internal void AddInfoBubble(InfoBubbleComponent bubble)
    {
        _mapInfoBubbleComponents.TryAdd(bubble.Guid, bubble);
    }

    internal void RemoveInfoBubble(InfoBubbleComponent bubble)
    {
        _mapInfoBubbleComponents.Remove(bubble.Guid);
    }

    internal void AddCluster(MarkerClusterComponent cluster)
    {
        _mapClusterComponents.TryAdd(cluster.Guid, cluster);
    }

    internal void RemoveCluster(MarkerClusterComponent cluster)
    {
        _mapClusterComponents.Remove(cluster.Guid);
    }

    internal void AddGeoJsonReader(GeoJsonReaderComponent reader)
    {
        _mapGeoJsonComponents.TryAdd(reader.Guid, reader);
    }

    internal void RemoveGeoJsonReader(GeoJsonReaderComponent reader)
    {
        _mapGeoJsonComponents.Remove(reader.Guid);
    }

    internal void AddKmlReader(KmlReaderComponent reader)
    {
        _mapKmlComponents.TryAdd(reader.Guid, reader);
    }

    internal void RemoveKmlReader(KmlReaderComponent reader)
    {
        _mapKmlComponents.Remove(reader.Guid);
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var component in _mapComponents)
        {
            component.Value.IsDisposed = true;
        }

        foreach (var component in _mapPolygonComponents)
        {
            component.Value.IsDisposed = true;
        }

        foreach (var component in _mapPolylineComponents)
        {
            component.Value.IsDisposed = true;
        }

        foreach (var component in _mapCircleComponents)
        {
            component.Value.IsDisposed = true;
        }

        foreach (var component in _mapRectComponents)
        {
            component.Value.IsDisposed = true;
        }

        foreach (var component in _mapGroupComponents)
        {
            component.Value.IsDisposed = true;
        }

        foreach (var component in _mapDomMarkerComponents)
        {
            component.Value.IsDisposed = true;
        }

        foreach (var component in _mapInfoBubbleComponents)
        {
            component.Value.IsDisposed = true;
        }

        if (MapRef != null)
        {
            await MapRef.DisposeAsync();
        }

        CallbackRef?.Dispose();
    }
}
